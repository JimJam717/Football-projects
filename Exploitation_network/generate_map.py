import pandas as pd
import folium
import re
from collections import defaultdict, Counter

# Load data (ONLY CRAWLER TABLE)
csv_file = 'Crawler_table.csv'
try:
    df = pd.read_csv(csv_file)
except FileNotFoundError:
    print(f"Error: '{csv_file}' not found.")
    exit()

# Coordinate mapping (approximate lat/lon)
country_coords = {
    # West/Central Africa (Origins)
    "Nigeria": [9.0820, 8.6753],
    "Ghana": [7.9465, -1.0232],
    "Ivory Coast": [7.5400, -5.5471],
    "Côte d'Ivoire": [7.5400, -5.5471],
    "Côte_d’Ivoire": [7.5400, -5.5471],
    "Côte d’Ivoire": [7.5400, -5.5471],
    "Cameroon": [7.3697, 12.3547],
    "Senegal": [14.4974, -14.4524],
    "Burkina Faso": [12.2383, -1.5616],
    "Burkina_Faso": [12.2383, -1.5616],
    "Mali": [17.5707, -3.9962],
    "Gambia": [13.4432, -15.3101],
    "The Gambia": [13.4432, -15.3101],
    "Zimbabwe": [-19.0154, 29.1549],
    "South Africa": [-30.5595, 22.9375],
    "South_Africa": [-30.5595, 22.9375],
    "Benin": [9.3077, 2.3158],
    "Cape Verde": [16.5388, -23.0418],
    "West Africa": [9.0000, -2.0000],

    # North Africa (Transit/Dest)
    "Tunisia": [33.8869, 9.5375],
    "Morocco": [31.7917, -7.0926],
    "Egypt": [26.8206, 30.8025],
    "Libya": [26.3351, 17.2283],
    
    # Europe (Destinations)
    "Italy": [41.8719, 12.5674],
    "France": [46.2276, 2.2137],
    "Spain": [40.4637, -3.7492],
    "Portugal": [39.3999, -8.2245],
    "Turkey": [38.9637, 35.2433],
    "Europe": [54.5260, 15.2551],
    
    # MENA / Asia
    "UAE": [23.4241, 53.8478],
    "Asia": [34.0479, 100.6197],
    "Asia/Middle East": [30.0000, 50.0000],
    "North Africa": [30.0, 20.0],
    "Middle East": [29.2985, 42.5510],
    
    # Southeast Asia / New Destinations
    "Thailand": [15.8700, 100.9925],
    "Cambodia": [12.5657, 104.9910],
    "Myanmar": [21.9162, 95.9560],
    "Mongolia": [46.8625, 103.8467],
    "Laos": [19.8563, 102.4955],
    "Southeast Asia": [13.0000, 105.0000]
}

def get_region_color(country):
    # Europe = blue
    europe = ["Italy", "France", "Spain", "Portugal", "Turkey", "Europe"]
    # MENA = orange
    mena = ["Tunisia", "Morocco", "Egypt", "Libya", "UAE", "Middle East", "North Africa", "Asia/Middle East"]
    # Asia = purple
    asia = ["Thailand", "Cambodia", "Myanmar", "Mongolia", "Laos", "Southeast Asia", "Asia"]
    # Intra-Africa = green (everything else in our list is likely Africa)
    
    if country in europe: return "#3388ff" # Blue
    if country in mena: return "#ff9900"   # Orange
    if country in asia: return "#9933ff"   # Purple
    return "#33cc33" # Green (Africa)

# Initialize Map
m = folium.Map(location=[9.0820, 8.6753], zoom_start=3, tiles='CartoDB dark_matter')

# Add Title
title_html = '''
     <div style="position: fixed; 
     top: 10px; left: 50px; width: 350px; height: 90px; 
     z-index:9999; font-size:16px; color: white;
     background-color: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; pointer-events: none;">
     <b>Patterns of Exploitation Routes</b><br>
     <small>Visualizing football trafficking networks, player origins, and exploitation hubs.</small>
     </div>
     '''
m.get_root().html.add_child(folium.Element(title_html))

# Create Layers
layer_routes = folium.FeatureGroup(name="Routes (Curved)")
layer_origins = folium.FeatureGroup(name="Origins")
layer_destinations = folium.FeatureGroup(name="Destinations")
layer_hubs = folium.FeatureGroup(name="Hubs / Transit")

node_roles = defaultdict(set)
node_stats = defaultdict(lambda: {"count": 0, "patterns": []})
edge_data = defaultdict(lambda: {"count": 0, "sources": []})

# 1. Process Data
for index, row in df.iterrows():
    orig = str(row['origin_country']).strip()
    dest = str(row['destination_country']).strip()
    
    # Normalize
    orig = re.sub(r'\(.*?\)', '', orig).replace('_', ' ').strip()
    dest = re.sub(r'\(.*?\)', '', dest).replace('_', ' ').strip()
    
    if not orig or not dest or orig not in country_coords or dest not in country_coords:
        continue
    
    # Track roles
    node_roles[orig].add('origin')
    node_roles[dest].add('destination')
    
    # Track stats
    node_stats[orig]["count"] += 1
    node_stats[dest]["count"] += 1
    
    medium = str(row['medium_type'])
    node_stats[orig]["patterns"].append(medium)
    node_stats[dest]["patterns"].append(medium)

    # Aggregate Edge Data
    edge_key = (orig, dest)
    edge_data[edge_key]["count"] += 1
    edge_data[edge_key]["sources"].append({
        "medium": medium,
        "link": row['article_link']
    })

# 2. Draw Nodes
for country, roles in node_roles.items():
    if country not in country_coords: continue
    
    stats = node_stats[country]
    # Calculate radius based on frequency (Visual Hierarchy)
    radius = 4 + (stats["count"] * 1.5)
    if radius > 25: radius = 25 # Cap max size
    
    # Determine dominant pattern
    if stats["patterns"]:
        most_common_pattern = Counter(stats["patterns"]).most_common(1)[0][0]
        # Simplify pattern text for tooltip
        short_pattern = most_common_pattern.split('(')[0].strip()
        if len(short_pattern) > 30: short_pattern = short_pattern[:30] + "..."
    else:
        short_pattern = "Unknown"

    # Determine Color and Layer
    if 'origin' in roles and 'destination' in roles:
        color = '#bf40bf' # Purple
        role_label = "Hub / Transit"
        target_layer = layer_hubs
    elif 'origin' in roles:
        color = '#00ff00' # Green
        role_label = "Origin"
        target_layer = layer_origins
    else:
        color = '#ff3333' # Red
        role_label = "Destination"
        target_layer = layer_destinations

    # Tooltip Content
    tooltip_text = f"""
    <b>{country}</b><br>
    Type: {role_label}<br>
    Incidents: {stats['count']}<br>
    Dominant: {short_pattern}
    """

    folium.CircleMarker(
        location=country_coords[country],
        radius=radius,
        color=color,
        fill=True,
        fill_color=color,
        fill_opacity=0.8,
        weight=1,
        tooltip=tooltip_text
    ).add_to(target_layer)

# 3. Draw Routes
for (org, dst), data in edge_data.items():
    start_coords = country_coords[org]
    
    # Color by Destination Region
    route_color = get_region_color(dst)
    
    if org == dst:
        tooltip_prefix = "<b>INTERNAL INCIDENT:</b> "
    else:
        tooltip_prefix = f"<b>Route: {org} → {dst}</b>"
    
    # Weight and Opacity
    weight = 1 + (data["count"] * 1.5)
    if weight > 10: weight = 10
    
    opacity = 0.5 if data["count"] < 3 else 0.7
    
    # Tooltip
    tooltip_html = f"{tooltip_prefix}<br>Reports: {data['count']}<br>Dest Region Color"

    if org == dst:
        # Self-loop
        # Make it a more visible loop (triangle shape) or longer offset
        end_coords = [start_coords[0] + 1.5, start_coords[1] + 1.5]
        # Force opacity to 1.0 for self-loops to ensure visibility
        opacity = 1.0
        weight = weight + 2
        
        folium.PolyLine(
            locations=[start_coords, end_coords],
            color=route_color,
            weight=weight,
            opacity=opacity,
            tooltip=tooltip_html
        ).add_to(layer_routes)

    else:
        end_coords = country_coords[dst]
        
        # Bezier Curve Calculation
        import numpy as np
        
        def get_bezier_path(p1, p2, num_points=20):
            # Calculate control point (midpoint + offset for curve)
            lat1, lon1 = p1
            lat2, lon2 = p2
            
            mid_lat = (lat1 + lat2) / 2
            mid_lon = (lon1 + lon2) / 2
            
            # Curve offset logic:
            # Perpendicular vector (dy, -dx)
            dx = lon2 - lon1
            dy = lat2 - lat1
            
            # Adjust offset magnitude based on distance
            dist = (dx**2 + dy**2)**0.5
            offset_magnitude = dist * 0.2  # 20% of distance
            
            # Direction of curve (e.g. always 'up' relative to line)
            # Use cross product logic or fixed offset
            control_lat = mid_lat - (dx * 0.2)
            control_lon = mid_lon + (dy * 0.2)
            
            # Bezier Formula: B(t) = (1-t)^2*P0 + 2(1-t)t*P1 + t^2*P2
            points = []
            for t in np.linspace(0, 1, num_points):
                lat = (1-t)**2 * lat1 + 2*(1-t)*t * control_lat + t**2 * lat2
                lon = (1-t)**2 * lon1 + 2*(1-t)*t * control_lon + t**2 * lon2
                points.append([lat, lon])
            return points

        path_coords = get_bezier_path(start_coords, end_coords)
        
        # Create Line (Single Layer)
        folium.PolyLine(
            locations=path_coords,
            color=route_color,
            weight=weight,
            opacity=opacity,
            tooltip=tooltip_html
        ).add_to(layer_routes)

# Add Layers to Map
layer_routes.add_to(m)
layer_origins.add_to(m)
layer_destinations.add_to(m)
layer_hubs.add_to(m)

# Add Layer Control
folium.LayerControl(collapsed=False).add_to(m)

# Legend HTML (Updated)
legend_html = '''
     <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
     <div style="position: fixed; 
     bottom: 20px; left: 20px; width: 250px; height: auto; 
     border:2px solid grey; z-index:9999; font-size:12px; font-family: 'Montserrat', sans-serif;
     background-color:rgba(255,255,255,0.9); padding: 10px; border-radius: 5px;">
     <b>Map Legend</b><br>
     <p style="margin-bottom: 5px;"><b>Node Types</b><br>
     <i style="color:#00ff00">●</i> Origin (Green)<br>
     <i style="color:#ff3333">●</i> Destination (Red)<br>
     <i style="color:#bf40bf">●</i> Hub / Transit (Purple)<br>
     <small>*Size indicates volume of reports</small>
     </p>
     <p style="margin-top: 5px;"><b>Route Colors (by Dest)</b><br>
     <span style="color:#3388ff">▬</span> Europe (Blue)<br>
     <span style="color:#ff9900">▬</span> Middle East/N.Africa (Orange)<br>
     <span style="color:#9933ff">▬</span> Asia (Purple)<br>
     <span style="color:#33cc33">▬</span> Intra-Africa (Green)<br>
     </p>
     </div>
     '''
m.get_root().html.add_child(folium.Element(legend_html))

# Custom CSS Toggle Control
# This script hides the default Leaflet control and injects a custom one with the user's specific CSS.
custom_control_script = """
<style>
/* From Uiverse.io by SelfMadeSystem */
.container {
  cursor: pointer;
}

.container input {
  display: none;
}

.container svg {
  overflow: visible;
  height: 2em;
  width: 2em;
}

.path {
  fill: none;
  stroke: white;
  stroke-width: 6;
  stroke-linecap: round;
  stroke-linejoin: round;
  transition: stroke-dasharray 0.5s ease, stroke-dashoffset 0.5s ease;
  stroke-dasharray: 241 9999999;
  stroke-dashoffset: 0;
}

.container input:checked ~ svg .path {
  stroke-dasharray: 70.5096664428711 9999999;
  stroke-dashoffset: -262.2723388671875;
}

/* Custom Control Panel Styles */
.custom-layer-control {
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 15px;
    border-radius: 10px;
    font-family: 'Montserrat', sans-serif;
    min-width: 200px;
    box-shadow: 0 0 15px rgba(0,0,0,0.5);
}
.custom-layer-control h4 {
    margin-top: 0;
    margin-bottom: 15px;
    font-size: 16px;
    border-bottom: 1px solid #555;
    padding-bottom: 5px;
}
.layer-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 8px;
}
.layer-label {
    margin-left: 10px;
    font-size: 14px;
}
</style>

<script>
document.addEventListener("DOMContentLoaded", function() {
    // Wait for Leaflet to populate the control
    setTimeout(function() {
        var baseControl = document.querySelector('.leaflet-control-layers');
        
        // Hide default Leaflet control visually but keep it active in DOM
        // We use visibility:hidden instead of display:none to ensure click events still work nicely
        if (baseControl) {
            baseControl.style.visibility = 'hidden';
            baseControl.style.opacity = '0';
            baseControl.style.pointerEvents = 'none';
            baseControl.style.position = 'absolute';
            baseControl.style.zIndex = '-1000';
        }

        var inputs = document.querySelectorAll('.leaflet-control-layers-selector');
        
        if (inputs.length === 0) return;

        // Create Custom Control Container
        var customPanel = document.createElement('div');
        customPanel.className = 'custom-layer-control leaflet-control';
        customPanel.innerHTML = '<h4>Layer Filters</h4>';
        // Ensure custom panel receives pointer events
        customPanel.style.pointerEvents = 'auto'; 
        
        var svgContent = `
        <svg viewBox="0 0 64 64" height="2em" width="2em"> 
            <path d="M 0 16 V 56 A 8 8 90 0 0 8 64 H 56 A 8 8 90 0 0 64 56 V 8 A 8 8 90 0 0 56 0 H 8 A 8 8 90 0 0 0 8 V 16 L 32 48 L 64 16 V 8 A 8 8 90 0 0 56 0 H 8 A 8 8 90 0 0 0 8 V 56 A 8 8 90 0 0 8 64 H 56 A 8 8 90 0 0 64 56 V 16" pathLength="575.0541381835938" class="path"></path> 
        </svg> 
        `;

        inputs.forEach(function(input, index) {
             // Get Layer Name
             // Use textContent instead of innerText because the parent control is hidden (visibility:hidden)
             // and innerText returns empty string for hidden elements.
             var labelText = input.nextSibling ? input.nextSibling.textContent.trim() : "Layer " + index;
             if (input.parentElement && input.parentElement.tagName === 'LABEL') {
                 labelText = input.parentElement.textContent.trim();
             }

             // Filter out cartodbdarkmatter
             if (labelText.toLowerCase().includes('cartodbdarkmatter') || labelText.toLowerCase().includes('cartodb')) {
                 return;
             }

             var layerId = "custom_layer_" + index;
             
             // Create Wrapper
             var wrapper = document.createElement('div');
             wrapper.className = 'layer-item';
             
             // Create Toggle (User's Style)
             var toggleLabel = document.createElement('label');
             toggleLabel.className = 'container'; // Updated class
             toggleLabel.title = "Toggle " + labelText;
             
             var toggleInput = document.createElement('input');
             toggleInput.type = 'checkbox';
             toggleInput.checked = input.checked;
             toggleInput.id = layerId;
             
             // Sync with Leaflet
             // When custom toggle changes, click the original Leaflet input
             toggleInput.addEventListener('change', function() {
                 if (input.checked !== toggleInput.checked) {
                     input.click();
                 }
             });

             // Also listen for changes on the original input (e.g. if map updates it)
             input.addEventListener('change', function() {
                 toggleInput.checked = input.checked;
             });
             
             // Append Input and SVG safely to preserve event listeners
             toggleLabel.appendChild(toggleInput);
             toggleLabel.insertAdjacentHTML('beforeend', svgContent);
             
             // Add Text Label
             var textSpan = document.createElement('span');
             textSpan.className = 'layer-label';
             textSpan.innerText = labelText;
             
             wrapper.appendChild(toggleLabel);
             wrapper.appendChild(textSpan);
             customPanel.appendChild(wrapper);
        });

        // Add to Map Control Area (Top Right)
        var controlArea = document.querySelector('.leaflet-top.leaflet-right');
        if (controlArea) {
            controlArea.appendChild(customPanel);
        }
    }, 1000); // Delay to ensure Leaflet has rendered
});
</script>
"""
m.get_root().html.add_child(folium.Element(custom_control_script))

output_file = 'football_trafficking_map.html'
m.save(output_file)
print(f"Map generated successfully: {output_file}")
